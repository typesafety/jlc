> Extensions:
    * One-dimensional arrays (arrays1).

> How to use:
After generating the executable `jlc` by running `make all` in the project
root, the compiler can be run as an executable with one Javalette source
file as its argument. Alternatively, the executable can read from stdin.

There is also an implementation of a prettyprinter for the JL ADT
(Frontend.PrettyPrinter), though it is has only been used for debugging.

No extra phases were added for this part of the assignment, and are still:

1. Lexing
2. Parsing
3. Type checking (1)                     (Frontend.TypeChecker):
4. Alpha-renaming                        (Frontend.AlphaRename):
5. Desugaring                            (Frontend.Desugar):
6. Optimization                          (Frontend.OptimizeAST):
7. Type checking and type annotation (2) (Frontend.TypeChecker):
8. LLVM ADT generation                   (LLVM.AdtGen):
9. LLVM code output                      (LLVM.Emit):

> Language specification:
Refer to the BNF grammar at src/Javalette.cf, or the generated
`Doc.txt` file generated by BNFC.

New grammar for the arrays1 extension:

* New value category `Var`. This is used to support array variables, and
    that we can both assign to and read from either the reference
    (int[] a; a = new int[2]), or some index in the array (a[1] = 10).
    Some rules that previously used `Ident` now uses `Var` where applicable.

* New value category `ArrIndex`. Allows the grammar to support indexing at
    arbirary nested levels of an array variable (arr[][][]...), even though
    the rest of the compilation phases do _not_ support multi-dimensional
    arrays.

* New Expr label ELength.

* New Expr label ENewArr.

* New Stmt label ForEach.

* New Type label Arr. Also introduces multiple levels of Type labels, though
    it is not strictly necessary as no other rule for Type is recursive.

> Shift/reduce conficts in the parser:

***
*** (No new conflicts were introduced with the new grammar. As such,
*** they are the same as for Part A and B.)
***

* There is one shift/reduce conflict that comes from the
"dangling else"-ambiguity. In the happy-generated info file, we have
something like this:

Stmt -> 'if' '(' Expr ')' Stmt .                    (rule 24)
Stmt -> 'if' '(' Expr ')' Stmt . 'else' Stmt        (rule 25)

where (.) indicates the current position.

If we have nested if-statements, we can have the following problem:

if (x) if (y) return a; . else return b;

where x and y are expressions.

Depending on whether we choose to shift the "else" or reduce the
current stack, we will end up with one of two interpretations:

Shift:
    if (x) {
        if (y) {
            return a;
        } else {
            return b;
        }
    }

Reduce:
    if (x) {
        if (y) {
            return a;
        }
    } else {
        return b;
    }

I.e. it becomes ambiguous whether the "else" should be attached to the
outer or the inner "if".

Choosing to always shift in these situations is conventional, and it
works fine, rather than going through the work of rewriting the grammar
to resolve the ambiguity.
